<html>
  <head>
    <style>
      .padding-20 {
        padding: 20px;
      }
    </style>
  </head>
  <body>
    <div id="main_container"></div>
    <script>
      const ReactInnerContext = {
        elementId: 0,
        activeId: null,
        stateMap: {},
        hookIdMap: {},
        renderTreeCreator: null,
        processedRenderTree: null,
        reactRootTreeElement: null,
        targetElement: null
      };

      function requestStateUpdateFor(elementId) {
        renderRoot(ReactInnerContext.renderTreeCreator, ReactInnerContext.targetElement, true);
      }

      function useState(initialState) {
        const activeElementId = ReactInnerContext.activeId;
        // if a second cook is used we need to be able to separate them
        if (!ReactInnerContext.hookIdMap[activeElementId]) {
          ReactInnerContext.hookIdMap[activeElementId] = 0;
        }
        const activeHookId = ReactInnerContext.hookIdMap[activeElementId]++;

        if (typeof ReactInnerContext.stateMap[activeElementId] === "undefined") {
          ReactInnerContext.stateMap[activeElementId] = {};
          ReactInnerContext.stateMap[activeElementId][activeHookId] = initialState;
        } else {
          if (typeof ReactInnerContext.stateMap[activeElementId][activeHookId] === "undefined") {
            ReactInnerContext.stateMap[activeElementId][activeHookId] = initialState;
          }
        }

        const stateUpdater = function (newState) {
          ReactInnerContext.stateMap[activeElementId][activeHookId] = newState;
          setTimeout(function () {
            requestStateUpdateFor(activeElementId);
          }, 50);
        };

        return [ReactInnerContext.stateMap[activeElementId][activeHookId], stateUpdater];
      }

      function createElement(typeOrFunction, props, children) {
        let renderTree = {
          $$id: `element-${ReactInnerContext.elementId++}`,
          type: typeOrFunction,
          props: props,
          children: null,
          $$nativeElement: null // will be filled later
        };

        if (typeof typeOrFunction === "function") {
          ReactInnerContext.activeId = renderTree.$$id;
          renderTree.children = typeOrFunction(props, children);
        } else {
          renderTree.children = children;
        }

        return renderTree;
      }

      function removeAllChildNodes(parent) {
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
      }

      function renderRoot(renderTreeCreator, targetElement, replacePreviousRoot) {
        //
        ReactInnerContext.activeId = -1;
        ReactInnerContext.elementId = 0;
        ReactInnerContext.hookIdMap = {};

        const processedRenderTree = renderTreeCreator();
        const reactRootTreeElement = document.createDocumentFragment();

        renderNode(processedRenderTree, reactRootTreeElement);

        if (replacePreviousRoot) {
          removeAllChildNodes(targetElement);
        }

        targetElement.appendChild(reactRootTreeElement);

        ReactInnerContext.reactRootTreeElement = reactRootTreeElement;
        ReactInnerContext.renderTreeCreator = renderTreeCreator;
        ReactInnerContext.processedRenderTree = processedRenderTree;
        ReactInnerContext.targetElement = targetElement;
      }

      function findAndInvokeEventListener(elementId, eventKey, evt) {
        const renderTree = ReactInnerContext.processedRenderTree;

        traverseAndFindElementByInnerId(renderTree, elementId, eventKey, evt);
      }

      function traverseAndFindElementByInnerId(elementNode, elementId, eventKey, evt) {
        if (elementNode.$$id === elementId) {
          elementNode.props?.events[eventKey]?.(evt);
        } else {
          if (elementNode.children) {
            if (Array.isArray(elementNode.children)) {
              elementNode.children.forEach((singleElement) => {
                traverseAndFindElementByInnerId(singleElement, elementId, eventKey, evt);
              });
            } else {
              traverseAndFindElementByInnerId(elementNode.children, elementId, eventKey, evt);
            }
          }
        }
      }

      // simple tree traversal
      function renderNode(node, parentElement) {
        if (node === null || node === undefined) {
          return;
        }

        if (Array.isArray(node)) {
          node.forEach((singleNode) => {
            renderSingleNode(singleNode, parentElement);
          });
        } else if (typeof node.type !== "function") {
          renderSingleNode(node, parentElement);
        } else {
          renderNode(node.children, parentElement);
        }
      }

      function renderSingleNode(node, parentElement) {
        const activeNode = document.createElement(node.type);
        activeNode.className = node?.props?.className;

        if (node.props?.__innerHTML) {
          activeNode.innerHTML = node.props?.__innerHTML;
        }

        node.$$nativeElement = activeNode;

        if (node.props?.events) {
          Object.keys(node.props?.events).forEach((key) => {
            activeNode.addEventListener(key, function (evt) {
              findAndInvokeEventListener(node.$$id, key, evt);
            });
          });
        }

        parentElement.appendChild(activeNode);

        renderNode(node.children, activeNode);
      }

      /// ----- Greeting.js
      function Greeting({ name }) {
        const [enabled, setEnabled] = useState(false);
        const [showDate, setShowDate] = useState(true);

        console.log("enabled", enabled);

        if (enabled) {
          return createElement("div", { className: "padding-20", __innerHTML: "Content removed" });
        }

        let preparedElement = null;
        if (showDate) {
          preparedElement = [
            createElement(
              "button",
              {
                className: "btn-primary",
                events: {
                  click: (evt) => {
                    // setEnabled(true);
                    setShowDate(false);
                    console.log("onclick");
                  }
                }
              },
              createElement("div", { __innerHTML: `Do you want to toggle ${name}?` })
            ),
            createElement("div", { __innerHTML: `${new Date().getTime()}` })
          ];
        } else {
          preparedElement = createElement("span", { __innerHTML: `Do you want to re-render ${name}?` });
        }

        return createElement("h1", { className: "greeting" }, preparedElement);
      }

      /// ---- App.js
      function App() {
        return createElement(
          "div",
          { className: "padding-20", __innerHTML: "Root div" },
          createElement(Greeting, { name: "Tayfun" })
        );
      }

      /// ------ index.js
      // import App from "./App.js";
      // import { renderRoot } from "./react.js";

      const renderTreeCreator = () => App();

      console.log(JSON.stringify(renderTreeCreator()));

      renderRoot(renderTreeCreator, document.getElementById("main_container"));
    </script>
  </body>
</html>
